# FAQ

### `Graphiti` とは何ですか？

時間情報付きナレッジグラフの自動構築・更新システムです。Neo4jとOpenAI APIを組み合わせ、動的に変化するデータからリアルタイムに知識グラフを生成し、ハイブリッド検索（埋め込み + BM25 + グラフ探索）で素早く情報を取得できます。

---

### `Graphiti`のユースケースを教えてほしいです

基本的には、これらを想定しています。まだ思いついていない使い方は他にもあるかと思います。

* チーム内のナレッジ検索（Slack / GitHub / Zoom を横断）
* インシデント・タスクの依存関係トレース
* PJ 内での担当者・サービス・インフラの関係把握

組織横断の巨大ドキュメント検索は `GraphRAG` の方が得意です。`Graphiti`はチーム単位で日々変わる知識に強いという特徴があります。

---

### MCP対応していますか？

はい。[graphiti-simple-chat](https://ghe.corp.yahoo.co.jp/ytonoyam/graphiti-simple-chat) には自作のMCPのコードも含まれます。
そのため、社内利用も可能です。[MCPに関する確認・問い合わせフロー / MCP Confirmation and Inquiry Flow](https://wiki.workers-hub.com/pages/viewpage.action?pageId=2592343328)のケースBに該当します。
簡易的にはClineやRoo Codeなどでも利用可能です。[graphiti-simple-chat](https://ghe.corp.yahoo.co.jp/ytonoyam/graphiti-simple-chat)はLangChainを使ったChatBotですが、Agent Development Kit(Apache-2.0)でももちろん使えます。

---

### 入力データの言語は日本語ですか？

いえ。英語で統一するのが良いかと思います。
uniQornチーム内でも言語をどうするのか？という議論はありましたが、[graphiti-core](https://github.com/getzep/graphiti)(Apache-2.0)標準の英語を使っています。
OpenAIのモデルは多言語対応のため、日本語、英語でもエンティティ、リレーションの情報抽出は行えますが、ベクトル検索を行う際に似た意味でも言語が違うと出てこなかったりする問題が発生します。
そのため、前処理として言語は統一する必要があります。
[graphiti-simple-chat](https://ghe.corp.yahoo.co.jp/ytonoyam/graphiti-simple-chat)では、データ入力時にLLMで翻訳するスクリプトを書いています。

---

### `Graphiti`を使ったFAQボットと普通のRAGを使ったFAQボットの異なる点は？

`Graphiti`の場合、ナレッジグラフにより因果・依存関係と訂正可能な知識を扱える点が違います。

ベクトル検索を使ったRAGは、近いテキストは取れますが、「誰が何をいつやった」「どのサービスがどれに依存している」といった構造は表現しづらいという問題点があります。
また、古い情報を訂正するという想定をしていないため、嘘が検索に引っかかっても直せないという点もあります。
この`Graphiti`を使ったBotでは、イベントと関係を構造化して保存しているため、「このサービス障害の根本原因は？誰が担当？どのコンポーネントと関係があるのか？」のような質問に、グラフを辿って答えられる特徴があります。

---

### Factとは何ですか？

メッセージやログなど複数のイベント間に存在する関係性を、LLM が自然言語で要約した文章(semantic fact)を「`Fact`」と`Graphiti`では呼んでいます。

例えば、
A: 「今日 API のレスポンスが急に遅くなった」
B: 「DB の CPU 使用率が95%に上がっている」
という文章があった際に`Graphiti`ではエンティティ(概念)とリレーション(関係性)を抽出し単純化した後に、
「API が遅くなった原因は、DB の CPU 使用率が95%まで上がったためである(英語)」
のような説明文である「`Fact`」を生成します。この`Fact`が`Graphiti`の利用者が検索に使うための文字列となります。

我々、人間がわざわざ自明だから説明しないよね？という実質的な暗黙知を`Graphiti`が生成してくれることでナレッジグラフが形成されていきます。

---

### Slack検索と違う点は何ですか？

Slack検索の場合、全文検索のため、「何を聞きたいかははっきりしてるが、どのスレを探せばいいか分からない」というタイプの質問では解決できるのですが、意味的に検索しようと思うと難しいです。また、依存関係は全文検索では取れません。
対して、`Graphiti`では、Slack・Issue・Zoomから構造化された`Fact`(メッセージの関係性をLLMで説明文にしたもの)を、ベクトル検索、全文検索の両方をあわせた結果をナレッジグラフから検索します。そのため、横断検索が可能です。
ただし、「この特定のメッセージを見たい」というピンポイントなケースでは検索Slack検索のほうが適している場合もあるかと思います。

本LTで公開した[Graphiti Simple Chat](https://ghe.corp.yahoo.co.jp/ytonoyam/graphiti-simple-chat)では実装されていませんが、ソース別に検索することも仕組み上簡単に実装可能です。

---

### 訂正ではどういう情報を訂正しているのか？また、実際は誰がどうやって訂正する想定なのか？

`Graphiti`では、検索結果から`Fact`を選んで、正しいと思う`Fact`を人間が明示して訂正します。
その操作が「新しい`Fact`（訂正）」として追加され、古い`Fact`を無効化します。ベクトルDBであるNeo4jに訂正履歴は残るため、「いつ誰がどう訂正したか」は追える仕組みになっています。
最初は間違っている部分もあるかもしれませんが、チーム全員で訂正することで実質的な集合地を作成できるのが特徴です。

---

### 実際にナレッジグラフが構築される精度について知りたいです

uniQornチームでSlack、Zoom、GitHub issueからgpt 4o-miniを使い、ナレッジグラフを作成した結果、[Graphiti Simple Chat BotのREADME.md](https://ghe.corp.yahoo.co.jp/ytonoyam/graphiti-simple-chat?tab=readme-ov-file#graphiti-simple-chat-bot)の画像にあるような検索結果となりました。

十分実用的な結果かと思います。しかし、一方で、生のZoomの文字起こしでは「API」が「エピア」のような間違った文字起こしにより、間違った`Fact`が形成された場合もありました。
生のZoom文字起こしのtxtファイルをChatGPTで綺麗にしたり、gpt 4o-miniを使ったGraphitiのによる結果のため、gpt-5にするなどの方法もあると思います。これは極端な例ですが、LLMは必ず間違えるため訂正もしくは、Episode(元の入力データ)を削除するGraphitiの機能が有用となります。

---

### 案件ごとにナレッジグラフを作成できますか？

はい。可能です。Episode(入力データ)を追加する際に`group_id`という文字列をオプションで指定することで、案件ごとのグラフを作成可能です。
指定なしだと`main`というデフォルトのナレッジグラフに追加されます。PJや案件ごとに分けるとちょうど良いかと思います。

---

### グラフにゴミが溜まる問題に対してどういう戦略がありますか？

大きく3つあるのかなと考えています。このうち1番目はSIG AI LTで発表したChatBotでも実装されています。

1. `Fact`訂正で誤りを無効化（消さずに「無効」という状態にする）
2. LLMを使ったガードレールで変なものをそもそも入れない（暴言・明らかなノイズなど）
3. 定期メンテナンス
   * 古すぎて意味の薄い`Fact`をアーカイブ
   * エンティティの統合/分割を人間がレビュー

従来のナレッジグラフでは、構築から人手で行っていましたが、`Graphiti`ではLLMが構築するため当然間違いは起こります。
そのため、`Fact`を訂正できる機能を使い、チーム全員で検索時のおまけとして訂正を行うことで、最低限の手間で新鮮な情報をいつも保った集合知となるナレッジグラフを作成できます。
忙しい現場でも利用するだけで育っていくAIを作れる仕組みです。

---

### `GraphRAG` と `Graphiti`の使い分けを知りたいです

`GraphRAG`と`Graphiti`は同じナレッジグラフではあるもののユースケースはかなり異なります。

* `GraphRAG`
  * 組織横断のドキュメント群を俯瞰したい
  * 大規模な階層構造のナレッジグラフを膨大なLLMで構築するため更新頻度は低くなり検索速度も時間はかかりますが、高度な構造化により検索精度の向上を期待できます。

* `Graphiti`
  * Slack / Zoom / Issueベースで毎日知識が変わるチーム内ナレッジ
  * チームやタスクの最新情報を追う際に便利です。
  * `GraphRAG`のように高度な階層構造は持てませんが、PJ内のサービス間の因果関係、依存関係がLLMで構築されつつSlack・GitHub Issue・Zoomを横断して意味的に検索できます。

どちらか一方に寄せるというよりも、「グローバルな地図（`GraphRAG`）＋ローカルな生ログ（`Graphiti`）」の二段構えとしてLangChainやAgent Development KitといったAIエージェントと組み合わせるのが理想的です。

---

### `Graphiti`はローカル環境で動きますか？

`Graphiti`はSaaSではなく、OpenAI APIを使いナレッジグラフの作成と検索を行うOSSです。
そのため、PCをネットワークから遮断しても完全ローカルのLM StudioによるLLMの実行でも動きます。
また、GraphRAGも同じくローカル環境で動きます。

---

### `Graphiti` を触ってみるにはどうすればよいですか？

まずはサンプルリポジトリである[Graphiti Simple Chat Bot](https://ghe.corp.yahoo.co.jp/ytonoyam/graphiti-simple-chat)から試すのがおすすめです。

`Graphiti`を使った簡易チャットボットとMCP対応コードが含まれています。まずは、`make demo`でデモデータで動作確認を行った後に、小さなチャンネルを対象にして、ちゃんと因果関係っぽい検索ができているかを確認すると良いかと思います。

---

### どんなデータソースを取り込めますか？

現状の想定データソースは以下です。

* Slack メッセージ（スレッドも含む）
* GitHub Issue / Pull Request のコメント
* Zoom の文字起こし

基本的に自作のGraphiti MCPを変更すれば様々なデータソースを読み込めます。
これらを1メッセージ単位のテキストとして取り込み、LLM でエンティティ・リレーション・Factを抽出したうえでナレッジグラフに登録します。

---

### `Graphiti` の全体アーキテクチャを簡単に知りたいです

ざっくり分けると、以下のような流れです。

1. 取り込み
* Slack / GitHub / Zoom などからメッセージやログを取得
* それぞれにタイムスタンプ・URL・チャンネル名などのメタ情報を付与

2. 構造化（LLM 処理）
* LLM で「誰が・何を・どうしたか」を抽出して Entity / Relation を生成
* 複数のメッセージ間の関係を説明する文章として「`Fact`（semantic fact）」を生成

3. 保存
* Neo4j にノード・エッジ・Fact・時間情報を格納
* Fact にはベクトル埋め込みも付与し、ベクトル検索＋BM25＋グラフ探索を組み合わせた検索ができるようにする

4. 検索
* ユーザーの質問をベクトル化して `Fact` を検索
* 関連するエンティティやリレーションをグラフ上で辿り、Factを検索し回答に反映

---

### どんな質問が`Graphiti`に向いていて、どんな質問が向いていませんか？

* 「Xサービスの最近の障害対応に関わったメンバーは誰ですか？」
* 「AチームとBチームが両方関わっているプロジェクトはありますか？」
* 「このインシデントと関係のある過去のトラブルは何がありますか？」

など「誰が・何を・いつ・なぜ・どう関係しているか」などの更新が激しい因果・依存関係を辿るタイプの質問に強いです。

「規程の第n条の文字列」のような、厳密な全文一致が欲しいケースは全文検索が向いています。
更新頻度が低いが複雑な依存関係を持つドキュメント群の質問は`GraphRAG`が向いています。

---

### 検索アルゴリズムは何を使っていますか？

ベクトル検索と全文検索を合わせ引っかかったFact(メッセージの関係性をLLMで説明文にしたもの)の結果を示すのが`Graphiti`です。
取り出されるFactと繋がっているノードには関連性があるため、幅優先探索でより多くの結果を取得するという検索オプションもあります。

---

### Bi-Temporal(二重時間)とはどういう仕組みですか？

出来事の発生時刻とメッセージの取り込み時刻の両方をNeo4jで扱っているという意味です。

`Graphiti`では「`Fact`発生時刻」と「グラフに取り込んだ時刻」を分けることで、いつ時点での真実かをクエリで指定することが可能です。

---

### DBは何を使っていますか？

Docker(Rancher Desktop)で[Neo4j Docker Image](https://github.com/neo4j/docker-neo4j/tree/master)(Apache-2.0)を使っています。

---

### Embeddingには何を使っていますか？

[text-embedding-bge-reranker-v2-m3](https://huggingface.co/BAAI/bge-reranker-v2-m3)(Apache-2.0)を使っています。

社内のPATでは`Embedding`モデルは提供していないためです。`635MB`という軽量ながらも実用的なモデルです。

---

### AIエージェントとして何を使っていますか？

[LangChain](https://github.com/langchain-ai/langchain)(MIT License)を使っています。Agent Development Kit(Apache-2.0)でも可能です。

---

### uniQornとは何ですか？

[千手観音プロジェクト～ASI時代を切り拓く新プロジェクト始動～](https://wiki.workers-hub.com/pages/viewpage.action?pageId=2691270575)で上位20チームに残った24卒同期で業務効率化AIを開発しているチームです。24卒同期の10名ほど構成されています。
